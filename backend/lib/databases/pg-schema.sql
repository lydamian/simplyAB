-- Seeing as we will be testing out this script alot we can destroy the db before creating everything again
DROP DATABASE IF EXISTS ab_testing_framework_db;

-- Create the db
CREATE DATABASE ab_testing_framework_db;

-- Move into the db
\c ab_testing_framework_db

-- Create our table if it doesn't already exist

DROP TYPE IF EXISTS user_types CASCADE;
CREATE TYPE user_types AS ENUM (
    'STANDARD',
    'ADMIN'
);

DROP TABLE IF EXISTS user_account CASCADE;
CREATE TABLE IF NOT EXISTS user_account
(
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  email_address text NOT NULL UNIQUE,
  username varchar(100) NOT NULL,
  password text NOT NULL,
  first_name varchar(100) NOT NULL,
  last_name varchar(100) NOT NULL,
  user_type user_types NOT NULL DEFAULT 'STANDARD',
  created_at timestamp with time zone DEFAULT (now())::timestamp with time zone NOT NULL,
  last_updated_at timestamp with time zone DEFAULT (now())::timestamp with time zone NOT NULL
);

DROP TABLE IF EXISTS project CASCADE;
CREATE TABLE IF NOT EXISTS project
(
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id BIGINT REFERENCES user_account(id) ON DELETE CASCADE,
  title varchar(100) NOT NULL UNIQUE,
  description text NOT NULL,
  created_at timestamp with time zone DEFAULT (now())::timestamp with time zone NOT NULL,
  last_updated_at timestamp with time zone DEFAULT (now())::timestamp with time zone NOT NULL
);

DROP TYPE IF EXISTS experiment_status CASCADE;
CREATE TYPE experiment_status AS ENUM (
  'DRAFT',
  'RUNNING',
  'PAUSED',
  'ARCHIVED',
  'DELETED'
);

DROP TABLE IF EXISTS experiment CASCADE;
CREATE TABLE IF NOT EXISTS experiment
(
  id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  project_id BIGINT REFERENCES project(id) ON DELETE CASCADE,
  title varchar(100) NOT NULL,
  key varchar(100) NOT NULL,
  description text NOT NULL,
  traffic_allocation_percentage INT NOT NULL,
  status experiment_status DEFAULT 'DRAFT' NOT NULL,
  created_at timestamp with time zone DEFAULT (now())::timestamp with time zone NOT NULL,
  last_updated_at timestamp with time zone DEFAULT (now())::timestamp with time zone NOT NULL,
  CONSTRAINT unique_experiment_title UNIQUE (project_id, title),
  CONSTRAINT unique_experiment_key UNIQUE (project_id, key)
);

DROP TABLE IF EXISTS experiment_entity CASCADE;
CREATE TABLE IF NOT EXISTS experiment_entity
(
  id BIGINT PRIMARY KEY,
  meta jsonb DEFAULT '{}' NOT NULL,
  created_at timestamp with time zone DEFAULT (now())::timestamp with time zone NOT NULL,
  last_updated_at timestamp with time zone DEFAULT (now())::timestamp with time zone NOT NULL
);

DROP TABLE IF EXISTS variant CASCADE;
CREATE TABLE IF NOT EXISTS variant
(
  id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  experiment_id INT REFERENCES experiment(id) ON DELETE CASCADE NOT NULL,
  key varchar(100) NOT NULL,
  title varchar(100) NOT NULL,
  traffic_allocation_percentage INT NOT NULL,
  created_at timestamp with time zone DEFAULT (now())::timestamp with time zone NOT NULL,
  last_updated_at timestamp with time zone DEFAULT (now())::timestamp with time zone NOT NULL,
  CONSTRAINT unique_variant_title UNIQUE (experiment_id, title),
  CONSTRAINT unique_variant_key UNIQUE (experiment_id, key)
);
-- @TODO: ADD check that each variant percent adds up to 100
-- ALTER TABLE variant 
-- ADD CONSTRAINT variant_percentage_sum_check 
-- CHECK (
-- 	price > 0
-- 	AND discount >= 0
-- 	AND price > discount
-- );

DROP TABLE IF EXISTS variant_assignment CASCADE;
CREATE TABLE IF NOT EXISTS variant_assignment
(
  variant_id INT REFERENCES variant(id) ON DELETE CASCADE NOT NULL,
  experiment_entity_id BIGINT REFERENCES experiment_entity(id) ON DELETE CASCADE NOT NULL,
  created_at timestamp with time zone DEFAULT (now())::timestamp with time zone NOT NULL,
  last_updated_at timestamp with time zone DEFAULT (now())::timestamp with time zone NOT NULL,
  CONSTRAINT no_duplicate_variant_assignment UNIQUE (variant_id, experiment_entity_id)
);

-- Changes the owner of the table to postgres which is the default when installing postgres
ALTER TABLE user_account
  OWNER to postgres;